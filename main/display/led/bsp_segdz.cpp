
#include "bsp_segdz.h"

//unsigned char seg7Code[16] = {0xFC, 0x60, 0xDA, 0xF2, 0x66, 0xB6, 0xBE, 0xE0, 0xFE, 0xF6};

//显示的字形数组，如果需要显示表中没有的形状，可以自己在数组后面添加
unsigned char seg7Code[]={
	SMG_0, 
	SMG_1,
	SMG_2,
	SMG_3,
	SMG_4,
	SMG_5,
	SMG_6,
	SMG_7,
	SMG_8,
	SMG_9,
	SMG_A,
	SMG_B,
	SMG_C,
	SMG_D,
	SMG_E,
	SMG_F,
};

unsigned char Disp_data[8] = {0, 0, 2, 1, 1, 9, 9, 9};



const unsigned char zdhz[][32] = {
{0x00,0x0C,0x18,0x18,0x00,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x78,0x38,0x18,0x00,0x06,0x06,0x06,0x06,0x06,0x06,0xFF,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06},/*"计",0*/
{0x30,0xF8,0x1F,0x18,0x18,0xFF,0x18,0x3C,0x7C,0x1E,0xDE,0x1B,0x18,0x18,0x18,0x18,0x18,0x19,0x1B,0x1B,0x18,0x19,0x1B,0x1B,0x18,0xF8,0x1F,0x18,0x18,0x18,0x18,0x18},/*"科",1*/
{0x00,0xE4,0x28,0x28,0xA1,0xA2,0xA2,0xA8,0xA8,0xA4,0xA7,0x84,0x44,0x44,0x24,0x10,0x20,0x23,0x22,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x20,0x21,0x22,0x28,0x10},/*"测",2*/
{0x00,0x04,0x08,0x08,0xE0,0x00,0x0F,0xE8,0x88,0x88,0x88,0xA8,0x98,0xE8,0x40,0x00,0x14,0x24,0x24,0x04,0x7F,0x04,0x04,0x07,0x04,0x08,0x08,0x08,0x53,0x50,0x60,0x40},/*"试",3*/
{0x80,0x80,0x80,0x80,0xFC,0x84,0x84,0x84,0x84,0x84,0xFC,0x84,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x1F,0x10,0x10,0x10,0x10,0x10,0x1F,0x10,0x00,0x00,0x00,0x00},/*"中",4*/
{0x80,0x80,0x80,0x80,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1F,0x10,0x00},/*"山",5*/

};


void hc595Send(unsigned char data)
{
	bsp_spiWrite0(data);	
}

void segSelect(char index)
{
	DISP_SEL_PORT->ODR &= ~(0x0f<<12);
	DISP_SEL_PORT->ODR |= index<<12;
}

void dzFlash(void)
{
  static int  dzIndex = 0;
	DZ595_DISable();
	hc595Send(zdhz[5][ dzIndex + 16]);//字的右半+16
	hc595Send(zdhz[5][ dzIndex]);//字的左半
	hc595Send(zdhz[4][ dzIndex + 16]);
	hc595Send(zdhz[4][ dzIndex]);
	DZ_ST_CLK();
	segSelect(dzIndex);
	DZ595_Enable();
	dzIndex++;
	if (dzIndex > 15)
		dzIndex = 0;
}


void segFlash(void)
{
  static int  segIndex = 0;
 	SEG595_DISable();//OE
	
	hc595Send(seg7Code[Disp_data[segIndex]]);
	SEG_ST_CLK();
	
	segSelect(segIndex);
	SEG595_Enable();
	segIndex++;
	if (segIndex > 7)
		segIndex = 0;
}


void seg_dz_GPIOInit(void)
{	
#ifdef proteus
	GPIO_InitTypeDef GPIO_InitStructure;
	/* 打开GPIO时钟 */
	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);	
	//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC, ENABLE);

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
#else	
	GPIO_InitTypeDef GPIO_InitStructure;
	/* 打开GPIO时钟 */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE, ENABLE);

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
	
#endif
	DISP_Enable();
	SEG595_Enable();
}


